// Scanner + Data Logger (ESP32)
// - Scans Eddystone-TLM using NimBLE-Arduino
// - Stores readings in per-MAC linked lists (dynamic memory using new/delete)
// - Every minute: sends CSV lines over Serial2, ends with "END\n"
// - Waits for "ACK\n" to free memory, otherwise keeps data for retry
// - LED2: blinking normally, SOLID when stored readings exceed threshold

#include <Arduino.h>
#include <NimBLEDevice.h>
#include <FastLED.h>
#include "NimBLEEddystoneTLM.h"

// ===== Config =====
#define SERIAL_BAUD      115200
#define SERIAL2_BAUD     115200
#define SERIAL2_TX_PIN   17   // adjust as needed
#define SERIAL2_RX_PIN   16

#define LED_PIN          4     // WS2812 LED pin
#define NUM_LEDS         1     // Only one LED
#define LED_BRIGHTNESS   255   // Full brightness
#define LED_TYPE         WS2812
#define COLOR_ORDER      GRB

CRGB leds[NUM_LEDS];

// ===== LED behavior =====
uint32_t ledBlinkInterval = 500;
unsigned long lastLedToggle = 0;
bool ledState = false;

#define STORE_INTERVAL_MS 60000UL  // 1 minute
#define MEMORY_HEAVY_THRESHOLD 200 // if total stored readings > this -> LED solid

// ===== Data structures =====
struct SensorData {
  float temperature;
  uint16_t voltage;
  uint32_t uptime;
  uint32_t advCount;
  int rssi;
  unsigned long timestamp; // millis of record
  SensorData* next;
};

struct SensorNode {
  String mac;
  SensorData* dataHead;
  SensorNode* next;
  SensorNode() : mac(""), dataHead(nullptr), next(nullptr) {}
};

static SensorNode* sensorList = nullptr;

// ===== NimBLE Scan handle =====
NimBLEScan* pBLEScan;

// ===== Utility functions =====
SensorNode* findOrCreateSensor(const String& mac) {
  for (SensorNode* n = sensorList; n; n = n->next) {
    if (n->mac == mac) return n;
  }
  // create node using new so String ctor runs
  SensorNode* node = new SensorNode();
  node->mac = mac;
  node->dataHead = nullptr;
  node->next = sensorList;
  sensorList = node;
  return node;
}

void addSensorData(SensorNode* sensor, float temp, uint16_t volt,
                   uint32_t uptime, uint32_t advCount, int rssi) {
  SensorData* d = new SensorData();
  d->temperature = temp;
  d->voltage = volt;
  d->uptime = uptime;
  d->advCount = advCount;
  d->rssi = rssi;
  d->timestamp = millis();
  d->next = sensor->dataHead;
  sensor->dataHead = d;
}

size_t totalStoredReadings() {
  size_t cnt = 0;
  for (SensorNode* n = sensorList; n; n = n->next) {
    for (SensorData* d = n->dataHead; d; d = d->next) ++cnt;
  }
  return cnt;
}

// Clear data for all sensors (free memory)
void clearAllData() {
  for (SensorNode* n = sensorList; n; n = n->next) {
    SensorData* d = n->dataHead;
    while (d) {
      SensorData* td = d;
      d = d->next;
      delete td;
    }
    n->dataHead = nullptr;
  }
}

// ===== Serial2 send logic =====
// Sends all data lines via Serial2 in CSV format:
// mac,temp,volt,uptime,advcount,rssi\n
// After sending lines, send "END\n" then wait for "ACK\n" or "NACK\n"
bool sendAllDataAndWaitAck(uint32_t timeoutMs = 2000) {
  // Send lines
  for (SensorNode* n = sensorList; n; n = n->next) {
    SensorData* d = n->dataHead;
    // iterate and send from oldest->newest? we store newest at head. We'll send head->...
    for (SensorData* cur = d; cur; cur = cur->next) {
      // Format numbers compactly
      Serial2.printf("%s,%.2f,%u,%u,%u,%d\n",
                     n->mac.c_str(),
                     cur->temperature,
                     cur->voltage,
                     cur->uptime,
                     cur->advCount,
                     cur->rssi);
      delay(5); // small spacing to avoid serial overruns (adjust if needed)
    }
  }
  // End marker
  Serial2.print("END\n");

  // Wait for ACK/NACK
  unsigned long start = millis();
  String resp = "";
  while (millis() - start < timeoutMs) {
    while (Serial2.available()) {
      char c = (char)Serial2.read();
      if (c == '\n') {
        resp.trim();
        if (resp == "ACK") return true;
        if (resp == "NACK") return false;
        resp = ""; // otherwise ignore and continue
      } else {
        resp += c;
      }
    }
    delay(5);
  }
  // timeout -> treat as NACK (no ack)
  return false;
}

// ===== NimBLE callback =====
class ScanCallbacks : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* advertisedDevice) override {
    NimBLEUUID eddyUUID = (uint16_t)0xFEAA;
    if (!advertisedDevice->haveServiceUUID() || !advertisedDevice->getServiceUUID().equals(eddyUUID)) return;
    std::string serviceData = advertisedDevice->getServiceData(eddyUUID);
    if (serviceData.empty() || (uint8_t)serviceData[0] != 0x20) return; // not TLM

    NimBLEEddystoneTLM tlm;
    tlm.setData(reinterpret_cast<const uint8_t*>(serviceData.data()), serviceData.length());

    // manual temp parsing (8.8 fixed)
    int rawTemp = ((uint8_t)serviceData[4] << 8) | (uint8_t)serviceData[5];
    float calcTemp = rawTemp / 256.0f;

    String mac = advertisedDevice->getAddress().toString().c_str();
    SensorNode* node = findOrCreateSensor(mac);
    addSensorData(node, calcTemp, tlm.getVolt(), tlm.getTime(), tlm.getCount(), advertisedDevice->getRSSI());
  }
};
static ScanCallbacks scanCallbacks;

void updateLED(bool isScanning, bool isSendingData, bool ackReceived, bool memoryExceeded) {
  size_t stored = totalStoredReadings();
  if (memoryExceeded || stored > MEMORY_HEAVY_THRESHOLD) {
    // Solid red if memory exceeds threshold or data is full
    leds[0] = CRGB::Red;  // Solid Red
    FastLED.show();
  } else if (isScanning) {
    // Green blinking when scanning and storing data
    if (millis() - lastLedToggle >= ledBlinkInterval) {
      lastLedToggle = millis();
      ledState = !ledState;
      if (ledState) {
        leds[0] = CRGB::Green;  // Green blink
      } else {
        leds[0] = CRGB::Black;  // Turn off LED
      }
      FastLED.show();
    }
  } else if (isSendingData) {
    // Blue blinking when sending data
    if (millis() - lastLedToggle >= ledBlinkInterval) {
      lastLedToggle = millis();
      ledState = !ledState;
      if (ledState) {
        leds[0] = CRGB::Blue;  // Blue blink
      } else {
        leds[0] = CRGB::Black;  // Turn off LED
      }
      FastLED.show();
    }
    // If ACK received, show Pink, else Yellow (NACK)
    if (ackReceived) {
      leds[0] = CRGB::Pink;  // Pink for ACK
      FastLED.show();
    } else {
      leds[0] = CRGB::Yellow;  // Yellow for NACK
      FastLED.show();
    }
  } else {
    // Off (default state when idle)
    leds[0] = CRGB::Black;  // Off
    FastLED.show();
  }
}

// ===== Setup & loop =====
unsigned long lastSendTime = 0;

void setup() {
  Serial.begin(SERIAL_BAUD);
  Serial2.begin(SERIAL2_BAUD, SERIAL_8N1, SERIAL2_RX_PIN, SERIAL2_TX_PIN);

  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(LED_BRIGHTNESS);

  Serial.println("\nðŸš€ BLE Scanner + Data Logger (Scanner ESP)");
  NimBLEDevice::init("ESP32-Scanner");
  pBLEScan = NimBLEDevice::getScan();
  pBLEScan->setScanCallbacks(&scanCallbacks, true); // allow duplicates
  pBLEScan->setActiveScan(true);
  pBLEScan->setInterval(100);
  pBLEScan->setWindow(99);
  pBLEScan->start(0, false, false);

  lastSendTime = millis();
}

void loop() {
  // LED update (non-blocking)
  bool isScanning = false;
  bool isSendingData = false;
  bool ackReceived = false;
  bool memoryExceeded = false;

  size_t stored = totalStoredReadings();
  if (stored > MEMORY_HEAVY_THRESHOLD) {
    memoryExceeded = true;
  }

  // Check if scanning BLE tags
  if (pBLEScan->isScanning()) {
    isScanning = true;
  }

  // Periodic send logic
  if (millis() - lastSendTime >= STORE_INTERVAL_MS) {
    lastSendTime = millis();
    Serial.println("Sending stored data via Serial2 ...");
    isSendingData = true;

    bool ok = sendAllDataAndWaitAck(3000); // 3s timeout for ACK
    if (ok) {
      ackReceived = true;
      Serial.println("ACK received -> clearing stored data");
      clearAllData();
    } else {
      ackReceived = false;
      Serial.println("No ACK / NACK -> will retry next minute. Data retained.");
    }
  }

  // Update LED status based on the conditions
  updateLED(isScanning, isSendingData, ackReceived, memoryExceeded);

  vTaskDelay(50 / portTICK_PERIOD_MS);  // Small delay to allow BLE scan updates
}
