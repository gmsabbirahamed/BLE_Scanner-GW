#include <Arduino.h>
#include <NimBLEDevice.h>
#include "NimBLEBeacon.h"
#include "NimBLEEddystoneTLM.h"
#include <WiFi.h>
#include <esp_now.h>


#define ENDIAN_CHANGE_U16(x) ((((x)&0xFF00) >> 8) + (((x)&0xFF) << 8))
#define SCAN_TIME_MS 5000  // 5 seconds scan time

typedef struct __attribute__((packed)) {
  char name[32];
  float tempC;
  uint16_t battery;
  int8_t rssi;
  uint32_t advCount;
  uint32_t uptimeDays;
} BeaconDataPacket;

uint8_t receiverMAC[] = {0xF0, 0x24, 0xF9, 0x44, 0xB5, 0x28}; // <-- Replace with RECEIVER ESP32 MAC
//F0:24:F9:44:B5:28


NimBLEScan* pBLEScan;

class ScanCallbacks : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* advertisedDevice) override {

    if (!advertisedDevice->haveName()) return; // skip if no name

    std::string devName = advertisedDevice->getName();
    if (devName != "KBPro_605504") return;  // only this device


    if (processiBeacon(advertisedDevice)) return;
    if (processEddystoneTLM(advertisedDevice)) return;

    // Extendable: Add your own processing rules here
  }

  bool processiBeacon(const NimBLEAdvertisedDevice* device) {
    if (!device->haveManufacturerData()) return false;

    std::string mData = device->getManufacturerData();
    if (mData.length() != 25 || (uint8_t)mData[0] != 0x4C || (uint8_t)mData[1] != 0x00) return false;

    NimBLEBeacon beacon;
    beacon.setData(reinterpret_cast<const uint8_t*>(mData.data()), mData.length());

    Serial.println("\nFound iBeacon");
    Serial.printf("   â–¸ Name  : %s \n", device->getName().c_str());
    Serial.printf("   â–¸ UUID  : %s\n", beacon.getProximityUUID().toString().c_str());
    Serial.printf("   â–¸ Major : %d\n", ENDIAN_CHANGE_U16(beacon.getMajor()));
    Serial.printf("   â–¸ Minor : %d\n", ENDIAN_CHANGE_U16(beacon.getMinor()));
    Serial.printf("   â–¸ Power : %d dBm\n", beacon.getSignalPower());
    Serial.printf("   â–¸ RSSI  : %d dBm\n", device->getRSSI());
    
    return true;
}




bool processEddystoneTLM(const NimBLEAdvertisedDevice* device) {
    NimBLEUUID eddyUUID = (uint16_t)0xFEAA;

    if (!device->haveServiceUUID() || !device->getServiceUUID().equals(eddyUUID)) return false;

    std::string serviceData = device->getServiceData(eddyUUID);
    if (serviceData.empty() || (uint8_t)serviceData[0] != 0x20) return false;

    NimBLEEddystoneTLM tlm;
    tlm.setData(reinterpret_cast<const uint8_t*>(serviceData.data()), serviceData.length());

    Serial.println("\nFound Eddystone-TLM Beacon");
    Serial.printf("   â–¸ Name            : %s \n", device->getName().c_str());
    Serial.printf("   â–¸ Battery Voltage : %d mV\n", tlm.getVolt());

    int rawTemp = (int)serviceData[5] + (int)(serviceData[4] << 8);
    float calcTemp = rawTemp / 256.0f;
    Serial.printf("   â–¸ Temp (raw calc) : %.2f Â°C\n", calcTemp);

    Serial.printf("   â–¸ Adv Count       : %d\n", tlm.getCount());
    Serial.printf("   â–¸ Uptime          : %d days\n", tlm.getTime() / 86400);
    Serial.printf("   â–¸ RSSI            : %d dBm\n", device->getRSSI());

    // Create and fill the data packet
    BeaconDataPacket packet;
    strncpy(packet.name, device->getName().c_str(), sizeof(packet.name) - 1);
    packet.name[sizeof(packet.name) - 1] = '\0';

    packet.tempC = calcTemp;
    packet.battery = tlm.getVolt();
    packet.rssi = device->getRSSI();
    packet.advCount = tlm.getCount();
    packet.uptimeDays = tlm.getTime() / 86400;

    // Send the packet via ESP-NOW
    esp_err_t result = esp_now_send(receiverMAC, (uint8_t*)&packet, sizeof(packet));
    if (result == ESP_OK) {
      Serial.println("ðŸ“¤ Data sent via ESP-NOW");
    } else {
      Serial.printf("âŒ ESP-NOW send failed (%d)\n", result);
    }

    return true;
}




};



ScanCallbacks scanCallbacks;

void setup() {
  Serial.begin(115200);
  Serial.println("\nðŸ“¡ BLE Beacon Scanner Initialized");



  WiFi.mode(WIFI_STA);
  if (esp_now_init() != ESP_OK) {
    Serial.println("âŒ ESP-NOW init failed");
    return;
  }

  // Add peer (destination MAC address must be known)
  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, receiverMAC, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;

  if (!esp_now_add_peer(&peerInfo)) {
    Serial.println("âœ… ESP-NOW peer added");
  } else {
    Serial.println("âŒ Failed to add peer");
  }






  NimBLEDevice::init("ESP32-Scanner");
  pBLEScan = BLEDevice::getScan();
  pBLEScan->setScanCallbacks(&scanCallbacks);
  pBLEScan->setActiveScan(true);  // Full scan data
  pBLEScan->setInterval(100);     // Time between scans
  pBLEScan->setWindow(99);        // Scan window <= interval
}

void loop() {
    NimBLEScanResults results = pBLEScan->getResults(SCAN_TIME_MS, false);
    Serial.print("Device found: ");
    Serial.print(results.getCount());
    Serial.println("Scan done!");
    pBLEScan->clearResults();
    delay(2000);
}
